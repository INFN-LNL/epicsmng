#!/usr/bin/env bash

######################################################
#                                                    #
#  Davide Marcato 2018                               #
#  epicsmng: script to manage epics modules          #
#                                                    #
#  DO NOT MODIFY THIS FILE                           #
#  Changes will be overwritten upon updating         #
#  Add your own configs inside:                      #
#  ~/.config/epicsmng/settings                       #
#                                                    #
######################################################


#module_url=""          - the url of the git repository or of files to download
#module_requires=""     - the modules that are required to compiled this one, to be set in configure/RELEASE
#module_optionals=""    - the optional modules to set in configure/RELEASE when available
#module_dbd=""          - the dbd files provided by the module, to be set in myApp/src/Makefile
#module_libs=""         - the libs files provided by the module, to be set in myApp/src/Makefile

base_url="https://git.launchpad.net/epics-base"
base_requires=""
base_optionals=""
base_dbd="base.dbd"
base_libs="\$(EPICS_BASE_IOC_LIBS)"

asyn_url='https://github.com/epics-modules/asyn.git'
asyn_requires="base"
asyn_optionals="sncseq ipac"
asyn_dbd="asyn.dbd drvAsynIPPort.dbd drvAsynSerialPort.dbd"
asyn_libs="asyn"

motor_url='https://github.com/epics-modules/motor'
motor_requires="base asyn"
motor_optionals="busy ipac sncseq"
motor_dbd="motorSupport.dbd"
motor_libs="motor"

ipac_url="https://github.com/epics-modules/ipac.git"
ipac_requires="base"
ipac_optionals=""
ipac_dbd="ipac.dbd"
ipac_libs="ipac"

streamdevice_url="https://github.com/paulscherrerinstitute/StreamDevice.git"
streamdevice_requires="base"
streamdevice_optionals=""
streamdevice_dbd="stream.dbd"
streamdevice_libs="stream"

calc_url='https://github.com/epics-modules/calc.git'
calc_requires="base"
calc_optionals="sscan sncseq"
calc_dbd="calc.dbd"
calc_libs="calc"

beckmotor_url="https://github.com/darcato/beckMotor.git"
beckmotor_requires="base asyn motor"
beckmotor_optionals=""
beckmotor_dbd="beckMotor.dbd"
beckmotor_libs="beckMotor"

modbus_url="https://github.com/epics-modules/modbus.git"
modbus_requires="base asyn"
modbus_optionals=""
modbus_dbd="modbusSupport.dbd"
modbus_libs="modbus"

autosave_url="https://github.com/epics-modules/autosave.git"
autosave_requires="base"
autosave_optionals=""
autosave_dbd="asSupport.dbd"
autosave_libs="autosave"

busy_url="https://github.com/epics-modules/busy.git"
busy_requires="base autosave asyn"
busy_optionals=""
busy_dbd="busySupport.dbd"
busy_libs="busy"

sscan_url="https://github.com/epics-modules/sscan.git"
sscan_requires="base"
sscan_optionals="sncseq"
sscan_dbd="sscanSupport.dbd"
sscan_libs="sscan"

sncseq_url="http://www-csr.bessy.de/control/SoftDist/sequencer/releases/"
sncseq_requires="base"
sncseq_optionals="sncseq"
sncseq_dbd=""
sncseq_libs="seq"

gensub_url="http://www.observatorysciences.co.uk/downloads/"
gensub_requires="base"
gensub_optionals=""
gensub_dbd="genSubRecord.dbd"
gensub_libs="genSub"


########################################################################

usr="$(whoami)"
basedir="/home/$usr/.config/epicsmng"
src="$basedir/src"
settingsdir="$basedir/settings"
patchesdir="$basedir/patches"

if ! install -d "$settingsdir"; then
    echo "WARNING: cannot create user configuration directory $settingsdir"
fi

if ! install -d "$src"; then
    echo "ERROR: cannot create source directory $src"
    exit 1
fi

if ! install -d "$patchesdir"; then
    echo "WARNING: cannot create patches directory $patchesdir"
fi

#if configdir empty, populate it with example user config
if [ -z "$(ls -A "$settingsdir")" ]; then
    cat >"$settingsdir"/user.settings <<EOF
#!/bin/bash
# Davide Marcato 2018
# Example of user settings for epicsmng
#
# ADD HERE CUSTOM SETTINGS
# var+="value"  -> create a new setting or add to its default value
# var="value"   -> create a new setting or substitute its default value

#module_url+=""          - the url of the git repository or of files to download
#module_requires+=""     - the modules that are required to compiled this one, to be set in configure/RELEASE
#module_optionals+=""    - the optional modules to set in configure/RELEASE when available
#module_dbd+=""          - the dbd files provided by the module, to be set in myApp/src/Makefile
#module_libs+=""         - the libs files provided by the module, to be set in myApp/src/Makefile

EOF
fi

#run user-supplied config files
for file in "$settingsdir"/*; do
  source "$file"
done

##### Common utilities #####

#this creates the folder containing the source of a module
#clones the repository
#and checkout to the required version
function prepare_git_src {
    remote="$1" #coincide with folder name
    module="$2"
    version="$3"
    
    cd "$src" || return 1
    #create folder with same name as module if not already present
    if [ ! -d "$module" ]; then
        echo "Cloning from repo $remote"
        if ! git clone "$remote" "$module"; then
            echo "ERROR: Git clone failed."
            return 1
        fi
        cd "$module" || return 1
    else  #if already present, simply fetch updates
        cd "$module" || return 1
        echo "Updating from repo $remote"
        if ! git fetch --all; then
            echo "WARNING: Git fetch failed."
            #do not return error, may still find required version on local repo
        fi
    fi    
    #discard local changes
    git checkout -- . 
    
    #checkout to the desired version (silencing detached head state)
    if ! git -c advice.detachedHead=false checkout "$version"; then
        echo "ERROR: Git version tag $version not found."
        echo "Example of available versions are:"
        git tag --sort=-version:refname | head -n 15
        return 1
    fi

    #apply user-supplied patches for this specific version
    if [ -d "$patchesdir/$module/$version" ] && [ ! -z "$(ls -A "$patchesdir/$module/$version")" ]; then
        for file in "$patchesdir/$module/$version"/*; do
            if ! git apply --check "$file"; then
                echo "The patch $file is incompatible. Please fix it."
                return 1
            fi
            git apply "$file"
        done
    fi
    cd "$top" || return 1    
    return 0
}

function set_makefile {
    echo " - Setting: $2 += $3"
    #file, token, value
    if grep -q -e "[# \\t]*$2[ \\t]*+=[ \\t]*$3" "$1" ; then
        #echo " - Using $3"
        #the token is present, update it
        sed -i -e "s/[# \\t]*$2[ \\t]*+=[ \\t]*$3/$2 += $3/" "$1"
    elif grep -q -e "^[# \\t]*$2[ \\t]*+=[^()$]*$" "$1"; then
        #echo " - Adding $3"
        # token not found, but found after: insert the token the line after
        linenum="$(grep -n -e "^[# \\t]*$2[ \\t]*+=[^()$]*$" "$1" | cut -d : -f 1 | tail -n1)"
        sed -i "${linenum}a\\$2 += $3" "$1"  #insert the line after
    else
        #else: write it at the end of file
        echo "Cannot determine where to write the dbd. Ignoring $3"
    fi
}

function set_config {
    echo " - Setting: $2 = $3"
    #file, token, value, beforeof
    if grep -q -e "[# \\t]*$2[ \\t]*=" "$1" ; then
        #the token is present, update it
        #echo " - Setting $3"
        sed -i -e "s/[# \\t]*$2[ \\t]*=.*/$2=$(echo "$3" | sed -e 's/\//\\\//g')/" "$1"
    elif grep -q -e "[# \\t]*$4[ \\t]*=" "$1"; then
        # token not found, but found beforeof: insert the token the line before
        #echo " - Adding $3"
        linenum="$(grep -n -e "[# \\t]*$4[ \\t]*=" "$1" | cut -d : -f 1 | head -n1)"
        sed -i "${linenum}i\\$2=$3" "$1"  #insert the line before $4
    else
        #else: write it at the end of file
        #echo " - Adding $3"
        echo "$2=$3" >> "$1"
    fi
}

function disable_config {
    #file, token
    echo " - Commenting: $2"
    sed -i -e "s/\\([ \\t]*$2[ \\t]*=.*\\)/# \\1/" "$1"
}

function set_release_par {
    #token, value
    set_config configure/RELEASE "$1" "$2" "EPICS_BASE"
}

function disable_release_par {
    #token
    disable_config configure/RELEASE "$1"
}

function set_site {
    str="$1"
    dest="$2"
    file="configure/CONFIG_SITE"

    if [ ! -r "$file" ]; then
        file="configure/CONFIG"
    fi

    #if not present exactly as required -> you are changing version    
    #if ! grep -q -e "^[ \\t]*$str[ \\t]*=[ \\t]*$dest/\?[ \\t]*\(#.*\)*$" $file; then
        set_config "$file" "$str" "$dest"
    #fi
}

#sets configure/release with path of the required modules to compile a module
#it reads the required ones from $module_requires variable
function set_requires {
    mod_to_build=$1

    requires="_requires"
    requires=$mod_to_build$requires  #something like asyn_requires
    for m in ${!requires}; do   #expanded to $asyn_requires
        #echo "$mod_to_build requires $m"
        module_up="$(echo -e "$m" | tr '[:lower:]' '[:upper:]')" #to uppercase
        if [ "$module_up" == 'BASE' ]; then
            module_up='EPICS_BASE'
        fi
        
        #search for the required module inside the modules to be installed  --TODO: change to installed ones
        indx=-1
        for j in "${!modules[@]}"; do
            if [ "${modules[$j]}" = "$m" ]; then
                indx=$j
                break
            fi
        done

        #if not found: error, it is required
        if [ "$indx" = -1 ]; then 
            echo "ERROR: $mod_to_build requires $m"
            return 1
        fi

        #set path inside module release
        set_release_par "$module_up" "$target/$m-${versions[$indx]}"
    done
}

#sets configure/release with path of the optional modules to compile a module
#it reads the optional ones from $module_optionals variable
function set_optionals {
    mod_to_build=$1

    optionals="_optionals"
    optionals=$mod_to_build$optionals  #something like asyn_optionals
    for m in ${!optionals}; do   #expanded to $asyn_optionals
        #echo "$mod_to_build can link to $m"
        module_up="$(echo -e "$m" | tr '[:lower:]' '[:upper:]')" #to uppercase
        if [ "$module_up" == 'BASE' ]; then
            module_up='EPICS_BASE'
        fi

        #search for the required module inside the modules to be installed  --TODO: change to installed ones
        indx=-1
        for j in "${!modules[@]}"; do
            if [ "${modules[$j]}" = "$m" ]; then
                indx=$j
                break
            fi
        done

        #if not found, comment it in configure/RELEASE, else uncomment and set path
        if [ "$indx" = -1 ]; then 
            disable_release_par "$module_up"
        else
            set_release_par "$module_up" "$target/$m-${versions[$indx]}"
        fi
    done
}

function compile_git {
    module="$1"
    version="$2"   
    dest="$target/$module-$version"

    url="_url"
    url="$module$url"
    if [ -z "${!url+x}" ]; then
        echo "Download url of $module not set. Please add it to $settingsdir/user.settings"
        return 1
    fi
    if ! prepare_git_src "${!url}" "$module" "$version"; then
        return 1
    fi
    
    cd "$src"/"$module" || return 1
    set_site 'INSTALL_LOCATION' "$dest"

    #set file configure release with target, the required modules and the optional ones
    set_release_par "SUPPORT" "$target"
    if ! set_requires "$module"; then
        echo "Unable to satisfy all requirements"
        return 1
    fi
    set_optionals "$module"

    echo "Building..."
    make clean > "$verbose" 2>&1
    make > "$verbose" 2>&1
}

function compile_file {
    module="$1"
    version="$2"
    fname="$3"
    dest="$target/$module-$version"

    mkdir -p "$src/$module"
    cd "$src/$module" || return 1
    if [ -d "$version" ]; then
        echo "folder exists"
        cd "$version" || return 1
    elif [ -f "$fname" ]; then
        echo "file exists"
        mkdir "$version"
        tar zxvf "$fname" --strip-components=1 -C "$version"
        cd "$version" || return 1
    else
        echo "Downloading..."
        url="_url"
        url="$module$url"
        if [ -z "${!url+x}" ]; then
            echo "Download url of $module not set. Please add it to $settingsdir/user.settings"
            return 1
        fi
        url=${!url}
        if ! wget "$url/$fname"; then
            echo "Failed to download: $url/$fname"
            return 1
        fi
        mkdir "$version"
        tar zxvf "$fname" --strip-components=1 -C "$version"
        cd "$version" || return 1
    fi
    
    set_site 'INSTALL_LOCATION' "$dest"
    disable_config configure/CONFIG 'CROSS_COMP.*'

    #set file configure release with target, the required modules and the optional ones
    set_release_par "SUPPORT" "$target"
    if ! set_requires "$module"; then
        echo "Unable to satisfy all requirements"
        return 1
    fi
    set_optionals "$module"

    echo "Building..."
    make clean > "$verbose" 2>&1
    make > "$verbose" 2>&1
};



##### Module Specific Compile Functions #####

function compile_base {
    version=$1
    dest="$target/base-$version"
    if ! compile_git "base" "$version"; then
        return 1
    fi

    cp -r startup "$dest/"
    if [ -d config ]; then
        cp -r config "$dest/"
    fi

    EPICS_HOST_ARCH="$("$dest"/startup/EpicsHostArch)"
    export EPICS_HOST_ARCH
    export base="$dest"
};

function compile_gensub {
    module="gensub"
    version="$1"
    fname="genSubV$version.tar.gz"
    
    compile_file "$module" "$version" "$fname"
};

function compile_sncseq {
    module="sncseq"
    version="$1"
    fname="seq-$version.tar.gz"
    
    compile_file "$module" "$version" "$fname"
};

function compile_streamdevice {
    module="streamdevice"
    version="$1"
    dest="$target/$module-$version"
    
    cd "$src" || return 1
    if [ ! -d "$module" ]; then
        mkdir "$module";
        cd "$module" || return 1
        "$base"/bin/"$EPICS_HOST_ARCH"/makeBaseApp.pl -t support empty
        if ! git clone "$streamdevice_url" "$module"; then
            echo "ERRORE: Git clone failed. Check connection."
            return 1
        fi
        cd "$module" || return 1
    else
        cd "$module/$module" || return 1
        echo "Updating from repo $remote"
        if ! git fetch --all; then
            echo "Git fetch failed"
            #do not return error, may still find required version on local repo
        fi
    fi    
    #discard local changes
    git checkout -- . 
    #checkout to the desired version
    if ! git -c advice.detachedHead=false checkout "$version"; then
        echo "ERRORE: Git version tag $version not found."
        return 1
    fi
    
    cd "$src/$module" || return 1
    set_site 'INSTALL_LOCATION' "$dest"
    
    #set file configure release with target, the required modules and the optional ones
    #set_release_par "SUPPORT" $target
    if ! set_requires "$module"; then
        echo "Unable to satisfy all requirements"
        return 1
    fi
    set_optionals "$module"

    echo "Building..."
    make -C $module --makefile Makefile clean > "$verbose" 2>&1
    make -C $module --makefile Makefile > "$verbose" 2>&1
}

##### Makemodules #####

function makemodules {  
    
    #create modules folder if not present
    if [ ! -d "$modulespath" ]; then
        if ! mkdir "$modulespath"; then
            echo "Cannot create modules folder $modulespath"
            exit 1
        fi
    fi

    #create configuration folder if not present
    if [ ! -d "$target" ]; then
        if ! mkdir "$target"; then
            echo "Cannot create configuration folder $target"
            exit 1
        fi
    fi

    #iterate on arrays and compile corresponding module
    for i in "${!modules[@]}"; do     
        echo "---"
        echo "Compiling ${modules[$i]}-${versions[$i]}"

        #otherversions="$(find $target -name "${modules[$i]}-*" | grep -v "${versions[$i]}")"
        #rm -rf $otherversions
        
        # if a special function is declared to compile this module, use it
        if [ "$(type -t compile_"${modules[i]}")" = "function" ]; then
            if ! compile_"${modules[i]}" "${versions[$i]}"; then
                echo "ERROR while compiling ${modules[$i]}-${versions[$i]}"
                echo "For more informations on compile errors try running with -v flag."
                exit 1
            fi
        else #else use the standard function to compile modules from git
            if ! compile_git "${modules[i]}" "${versions[$i]}"; then
                echo "ERROR while compiling ${modules[$i]}-${versions[$i]}."
                echo "For more informations on compile errors try running with -v flag."
                exit 1
            fi
        fi
    done
    echo ""
    
    #remove unused compiled modules
    for dir in "$target"/*/ ; do
        found=false
        for i in "${!modules[@]}"; do  
            if [ "${modules[$i]}-${versions[$i]}" = "$(basename "$dir")" ]; then
                found=true
                break
            fi
        done
        if [ "$found" = false  ]; then
            echo "Removing unused module $dir"
            rm -rf "$dir"
        fi
    done

}
##### Cleanmodules #####

function cleanmodules {

    # if I cannot read it (file not present or unreadable) error
    if [ ! -d "$target" ]; then
        echo "Cannot find installed configuration $confname"
        exit 1
    else
        echo "Removing $target"
        rm -rf "$target"
    fi
}

##### Configureioc #####

function configure_apps {
    cd "$top" || return 1
    folders="$(ls -d ./*App)"
    for d in $folders; do
        echo ""
        echo "Configuring $top/$d/src/Makefile"
        set_dbd_libs "$d/src/Makefile" "${d: : -3}" "dbd"    
        set_dbd_libs "$d/src/Makefile" "${d: : -3}" "libs"
    done
}

function set_dbd_libs {
    file=$1
    appname=$2"_""$(echo -e "$3" | tr '[:lower:]' '[:upper:]')" # something like myapp_DBD or myapp_LIBS
    type=$3

    #first set new dbds, uncommenting the existing ones or doing nothing if already present
    for m in "${modules[@]}"; do     
        dbds=$m"_"$type  #something like asyn_dbd
        for dbd in ${!dbds}; do
            set_makefile "$file" "$appname" "$dbd"
        done
    done

    #then comment lines containing dbds not in this configuration
    while read -r line ; do
        set="$(echo "$line" | grep -o -e "\\S*[ \\t]*\\(#.*\\)*$")"
        found=false
        for m in "${modules[@]}"; do     
            dbds=$m"_"$type  #something like asyn_dbd
            for _d in ${!dbds}; do
                if [ "$set" = "$_d" ]; then
                    found=true
                    break
                fi
            done
        done
        if [ "$found" = false  ]; then
            echo " - Commenting: $set"
            sed -i "s/.*$line/#&/" "$file"
        fi
    done < <(grep -e "^[ \\t]*${appname}[ \\t]*+=.*[ \\t]*\\(#.*\\)*$" "$file")
}

function configureioc {
    #iterate on arrays and compile corresponding module
    echo ""
    echo "Configuring $top/configure/RELEASE"
    for j in "${!modules[@]}"; do     
        #echo "Configuring ioc to use ${modules[$j]}-${versions[$j]}"
        module_up="$(echo -e "${modules[$j]}" | tr '[:lower:]' '[:upper:]')" #to uppercase
        set_release_par "$module_up" "\$(TOP)/modules/$confname/${modules[$j]}-${versions[$j]}"
    done

    configure_apps

    #if gitignore not present, but top is a git repo -> create gitignore
    if [ ! -r "$top/.gitignore" ] && [ -d "$top/.git" ]; then
        touch "$top/.gitignore"
    fi

    #if gitignore is present but modules/ is not listed, add it
    if [ -r "$top/.gitignore" ]; then
        if ! grep -q -F "modules/" "$top/.gitignore"; then
            echo "modules/" >> "$top/.gitignore"
        fi
    fi
}

##### LISTMODULES #####

function listmodules {
    echo "Available modules:"
    echo "------------------"
    set -o posix; set | grep "_url" | grep -o -e "^[^_]*"
}

##### EPICSMNG #####

top="$(pwd)"  #top default path is "."
verbose="/dev/null"  #verbosity: default=non verbose

usage() { 
    echo ""
    echo "USAGE: $0 command args"
    echo "     command - one of the supported commands"
    echo "     args    - the command arguments"
    echo ""
    echo "Supported commands:"
    echo " - makemodules [-C <path>] [-j <n>] [-v] configuration"
    echo " - cleanmodules [-C <path>] configuration"
    echo " - configureioc [-C <path>] configuration"
    echo ""
    echo "Arguments:"
    echo " - configuration - a file describing the epics modules to be installed"
    echo " - -C <path>     - where to install modules"
    echo " - -j <n>        - parallel jobs on make"
    echo " - -v            - enable verbose mode"
    echo ""
    exit 1; 
}

# the first non-optional parameter must be the command
if (( $# < 1 )); then
    usage
fi
command=$1
shift 1  #shift so that now optional args are first (required by optargs)

# parse optional argument [-C <top>]
while getopts ":C:j:v" o; do
    case "${o}" in
        C)
            top="$(realpath "${OPTARG}")"  #save absolute path in top
            ;;
        j)  export MAKEOPTS="-j$OPTARG"
            export MAKEFLAGS="-j$OPTARG"
            ;;
        v)  verbose="/dev/stdout" #more verbose
            ;;
        *)
            echo "Wrong optional argument"
            usage
            ;;
    esac
done
shift "$((OPTIND-1))"

# if the supplied path is an empty string, error
if [ -z "$top" ]; then
    usage
fi

if [ "$command" != "listmodules" ]; then
    # There must be the configuration file
    if [ $# -ne 1 ]; then
        usage
    fi
    configfile="$1" #was the $2 but shifted

    # if I cannot read it (file not present or unreadable) error
    if [ ! -r "$configfile" ]; then
        echo "Cannot read file $configfile"
        exit 1
    fi

    #echo configuration name
    confname="$(basename -- "$configfile")"
    confname="${confname%.*}"
    echo "Configuration: -> $confname <-"

    #where to install binaries
    modulespath="$top/modules"
    target="$modulespath/$confname"

    #parse config file
    declare -a modules #an array to store found modules
    declare -a versions #an array to store found versions
    while IFS='=' read -r module version
    do
        if [[ $version ]]
        then
            module="$(echo -e "$module" | tr '[:upper:]' '[:lower:]')" #to lowercase
            module="$(echo -e "$module" | tr -d '[:space:]')" #remove spaces
            modules+=( "$module" ) #add to array
            version="$(echo -e "$version" | tr -d '[:space:]')" #to lowercase        
            versions+=( "$version" ) #add to array
            echo "  $module - $version"
        fi
    done < <(grep -o '^[^#]*' "$configfile") #a copy without comments

    if [ "${modules[0]}" != "base" ]; then
        echo "ERROR: base must be the first module in the configuration"
        exit 0
    fi
fi


#main command launcher
case "$command" in
makemodules)
	makemodules
	;;
cleanmodules)
    cleanmodules
    ;;
configureioc)
    configureioc
    ;;
listmodules)
    listmodules
    ;;
*)
	echo "Unknown command '$command'"
	usage
	exit 1
	;;
esac
echo "--- Completed ---"