#!/bin/bash


#################################### COPIED
function set_config {
    #file, token, value, beforeof
    if grep -q -e "[# \t]*$2[ \t]*=" $1 ; then
        #the token is present, update it
        sed -i -e "s/[# \t]*$2[ \t]*=.*/$2=$(echo $3 | sed -e 's/\//\\\//g')/" $1
    else if grep -q -e "[# \t]*$4[ \t]*=" $1; then
        # token not found, but found beforeof: insert the token the line before
        linenum="$(grep -n -e "[# \t]*$4[ \t]*=" $1 | cut -d : -f 1 | head -n1)"
        sed -i ""$linenum"i\\$2=$3" $1  #insert the line before $4
    else
        #else: write it at the end of file
        echo "$2=$3" >> $1
    fi
    fi    
}

function disable_config {
    #file, token
    sed -i -e "s/\([ \t]*$2[ \t]*=.*\)/# \1/" $1
}

function set_release_par {
    #token, value
    set_config configure/RELEASE $1 $2 "EPICS_BASE"
}

function disable_release_par {
    #token
    disable_config configure/RELEASE $1
}

#################################### COPIED

top="$(pwd)"  #top default path is "."

usage() { 
    echo "USAGE: $0 [-C <path>] configuration"
    echo "     configuration - a config file describing the epics modules to be removed"
    exit 1; 
}

# parse optional argument [-C <top>]
while getopts ":C:" o; do
    case "${o}" in
        C)
            top="$(realpath ${OPTARG})"  #save absolute path in top
            ;;
        *)
            usage
            ;;
    esac
done
shift "$((OPTIND-1))"

# if the supplied path is an empty string, error
if [ -z "$top" ]; then
    usage
fi

# the first non-optional parameter must be the config file
if [ "$#" -ne 1 ]; then
    echo "Wrong number of parameters"
    usage
fi

configfile="$1"
confname="$(basename -- "$configfile")"
confname="${confname%.*}"
dir=$top/modules/$confname

#where to install binaries
modulespath="$top/modules"
target="$modulespath/$confname"

#####################################


function set_makefile {
    #file, token, value, extension
    if grep -q -e "[# \t]*$2[ \t]*+=[ \t]*$3" $1 ; then
        #the token is present, update it
        sed -i -e "s/[# \t]*$2[ \t]*+=.*/$2+=$3" $1
    else if grep -q -e "[# \t]*$2[ \t]*+=.*"$4"" $1; then
        # token not found, but found after: insert the token the line before
        linenum="$(grep -n -e "[# \t]*$2[ \t]*+=.*"$4"" $1 | cut -d : -f 1 | tail -n1)"
        sed -i ""$linenum"a\\$2+=$3" $1  #insert the line after
    else
        #else: write it at the end of file
        echo "Cannot determine where to write the dbd. Ignoring $3"
    fi
    fi 
}

function set_dbd {
    module=$1
    cd dbd
    dbd=""
    if find . -iname "$module.dbd"; then
        dbd=$(find . -iname "$module.dbd")
    else if find . -iname ""$module"Support.dbd"; then
        dbd=$(find . -iname ""$module"Support.dbd")
    else
        echo "Cannot determine the correct DBD to install: ignoring dbd of $module"
        return 1
    fi
    fi

    #keep only file name from path
    dbd="$(basename -- "$dbd")"

    cd $top
    folders="$(ls -d *App)"
    for d in "$folders"; do
        cd $d/src/
        set_makefile Makefile "${d: : -3}"_DBD $dbd ".dbd"
    done
    
}

function set_libs {
    module=$1
    cd lib
    libs=""
    if find . -iname "lib$module\.so"; then 
        libs=$(find . -iname "lib$module\.so | head -n1")
    else
        echo "Cannot determine the correct LIBS to install: ignoring libs of $module"
        return 1
    fi

    #keep only file name from path
    libs="$(basename -- "$libs")" 
    libs="${libs%.*}"   #remove .so
    libs="${libs:3}"    #remove trailing lib

    cd $top
    folders="$(ls -d *App)"
    for d in "$folders"; do
        cd $d/src/
        set_makefile Makefile "${d: : -3}"_LIBS $libs ""
    done
}




#parse config file
tmpfile=$(mktemp)  #create temporary file
grep -o '^[^#]*' "$configfile" > "$tmpfile"  #a copy without comments
declare -a modules #an array to store found modules
declare -a versions #an array to store found versions
while IFS='=' read module version
do
    if [[ $version ]]
    then
        module="$(echo -e "$module" | tr '[:upper:]' '[:lower:]')" #to lowercase
        module="$(echo -e "$module" | tr -d '[:space:]')" #remove spaces
        modules+=( "$module" ) #add to array
        version="$(echo -e "$version" | tr -d '[:space:]')" #to lowercase        
        versions+=( "$version" ) #add to array
        echo "  $module - $version"
    fi
done < "$tmpfile"
rm "$tmpfile"

#iterate on arrays and compile corresponding module
for i in "${!modules[@]}"; do     
    echo "---"
    echo "Configuring ioc to use ${modules[$i]}-${versions[$i]}"
    cd $top
    if [ ! -d $target/${modules[$i]}-${versions[$i]} ]; then
        echo "Module $target/${modules[$i]}-${versions[$i]}. Skipping..."
        continue
    fi

    module_up="$(echo -e "${modules[$i]}" | tr '[:lower:]' '[:upper:]')" #to uppercase
    set_release_par "$module_up" "\$(TOP)/modules/${modules[$i]}-${versions[$i]}"

    if [ "${modules[$i]}" != "base" ]; then
        echo "${modules[$i]}"
        cd $target/${modules[$i]}-${versions[$i]}
        set_libs "${modules[$i]}"
        cd $target/${modules[$i]}-${versions[$i]}
        set_libs "${modules[$i]}"
    fi
done

# cercare tutte le cartelle che finisco per App
# mi salvo il nome dell'app
# per ogni cartella entrare in src
# modificare makefile
# cerco nomeapp_DBD e aggiungo dopo l'ultima riga che finisce per .dbd
# empty_DBD += xxx.dbd
# lo stesso per empty_LIBS

#problema con stream name